package com.SixSense.threading;

import com.SixSense.api.http.overrides.HTTPThreadExecutor;
import com.SixSense.config.ThreadingConfig;
import com.SixSense.data.events.EngineEventType;
import com.SixSense.data.threading.MonitoredThread;
import com.SixSense.data.threading.ThreadPool;
import org.apache.catalina.connector.Connector;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.springframework.amqp.rabbit.connection.CachingConnectionFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.embedded.tomcat.TomcatWebServer;
import org.springframework.stereotype.Component;

import java.io.Closeable;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.*;
import java.util.function.Consumer;
import java.util.function.Supplier;

/*Manages all multi-threaded executables generated by the engine*/
@Component
@EnableConfigurationProperties(ThreadingConfig.class)
public class ThreadingManager implements Closeable {
    private static final Logger logger = LogManager.getLogger(ThreadingManager.class);
    private final ThreadPoolExecutor enginePool; //Executes all tasks originating from the engine itself (com.SixSense.*)
    private final HTTPThreadExecutor httpConnectionPool; //Executes all threads intercepting web requests (org.apache.catalina.*) [NOT all tomcat threads]
    private final ThreadPoolExecutor amqpConnectionPool;

    private final ThreadingConfig.ThreadingProperties engineProperties;
    private final ThreadingConfig.ThreadingProperties httpProperties;
    private final ThreadingConfig.AMQPThreadingProperties amqpProperties;

    private boolean isClosed = false;

    @Autowired
    private ThreadingManager(ThreadingConfig threadingConfig){
        this.engineProperties = threadingConfig.getEngine();
        this.httpProperties = threadingConfig.getHttp();
        this.amqpProperties = threadingConfig.getAmqp();

        this.enginePool = generateThreadPool(this.engineProperties);
        this.httpConnectionPool = new HTTPThreadExecutor(this.httpProperties);
        this.amqpConnectionPool = generateThreadPool(this.amqpProperties);

        this.enginePool.prestartAllCoreThreads();
        this.amqpConnectionPool.prestartAllCoreThreads();
    }

    private ThreadPoolExecutor generateThreadPool(ThreadingConfig.ThreadingProperties threadingProperties){
        return new ThreadPoolExecutor(
                threadingProperties.getMinimumThreads(),
                threadingProperties.getMaximumThreads(),
                threadingProperties.getAllowedIdleTime().toMillis(),
                TimeUnit.MILLISECONDS,
                new SynchronousQueue<>(), //To allow for dynamic size increase, we must provide a synchronousQueue (https://stackoverflow.com/a/8591681/1658288, https://stackoverflow.com/a/47691139/1658288)
                new EngineThreadFactory(threadingProperties)
        );
    }

    public <V> CompletableFuture<V> submit(Supplier<V> worker){
        if(this.isClosed){
            return CompletableFuture.failedFuture(new Exception("Cannot submit supplier to work queue - worker pool has been closed"));
        }else{
            return CompletableFuture.supplyAsync(worker, enginePool);
        }
    }

    public <V> void acceptAsync(CompletableFuture<V> future, Consumer<? super V> action){
        if(this.isClosed){
            future.completeExceptionally(new Exception("Cannot apply action to future task - worker pool has been closed"));
        }else{
            future.thenAcceptAsync(action, enginePool);
        }
    }

    public void submit(Runnable worker) throws Exception{
        if(this.isClosed){
            throw new Exception("Cannot submit runnable to work queue - worker pool has been closed");
        }
        enginePool.submit(worker);
    }

    public void injectServletWithPool(TomcatWebServer embeddedServer){
        embeddedServer.getTomcat().getService().addExecutor(this.httpConnectionPool);
    }

    public void injectConnectorWithPool(Connector connector){
        connector.getProtocolHandler().setExecutor(this.httpConnectionPool);
    }

    public void injectAMQPFactoryWithPool(CachingConnectionFactory connectionFactory){
        connectionFactory.setExecutor(this.amqpConnectionPool);
        connectionFactory.getRabbitConnectionFactory().setSharedExecutor(this.amqpConnectionPool);

        //note that connection and channel open/close is expensive, so in high-throughput environments we would prefer keeping a lot of them open (cached)
        connectionFactory.setConnectionCacheSize(this.amqpProperties.getMinimumConnections());
        connectionFactory.setChannelCacheSize(this.amqpProperties.getMinimumChannels());
    }

    private IThreadMonitoingFactory getMonitoringThreadFactory(ThreadPool threadPool){
        switch (threadPool){
            case Engine: return (EngineThreadFactory)this.enginePool.getThreadFactory();
            case HTTP: return this.httpConnectionPool.getThreadFactory();
            case AMQP: return (EngineThreadFactory)this.amqpConnectionPool.getThreadFactory();
            default: throw new IllegalArgumentException("No managed thread pool named " + threadPool.name() + " exists");
        }
    }

    public Map<String, EngineEventType> getEngineThreadStatus(){
        IThreadMonitoingFactory monitoringThreadFactory = getMonitoringThreadFactory(ThreadPool.Engine);
        Set<MonitoredThread> currentThreads = monitoringThreadFactory.getMonitoredThreads();

        Map<String, EngineEventType> threadStatus = new HashMap<>();
        for(MonitoredThread thread : currentThreads){
            threadStatus.put(thread.getName(), thread.getCurrentLifecyclePhase());
        }

        return threadStatus;
    }


    public boolean isShutdown(){
        return enginePool.isShutdown();
    }

    @Override
    public void close() {
        this.enginePool.shutdownNow();
        this.isClosed = true;
        logger.info("WorkerQueue closed");
    }
}
