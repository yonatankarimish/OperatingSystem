package com.sixsense.services;

import com.sixsense.config.HostConfig;
import com.sixsense.config.SessionConfig;
import com.sixsense.model.events.*;
import com.sixsense.model.logic.*;
import com.sixsense.model.commands.Operation;
import com.sixsense.model.commands.Block;
import com.sixsense.model.commands.Command;
import com.sixsense.model.commands.ICommand;
import com.sixsense.model.retention.OperationResult;
import com.sixsense.io.ProcessStreamWrapper;
import com.sixsense.io.Session;
import com.sixsense.io.ShellChannel;
import com.sixsense.threading.ThreadingManager;
import com.sixsense.utillity.LogicalExpressionResolver;
import com.sixsense.utillity.Literals;
import com.sixsense.utillity.ThreadingUtils;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.ThreadContext;
import org.springframework.beans.BeansException;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Service;

import java.io.*;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

/*Creates sessions and executes operations*/
@Service
@EnableConfigurationProperties({SessionConfig.class, HostConfig.class})
public class SessionEngine implements ApplicationContextAware {
    private static final Logger logger = LogManager.getLogger(SessionEngine.class);
    private ApplicationContext appContext;
    private final ThreadingManager threadingManager;
    private final DiagnosticManager diagnosticManager;
    private final LoggingManager loggingManager;

    private final SessionConfig sessionConfig;
    private final HostConfig.Host localhostConfig;


    private static final Map<String, String> sessionProperties = new ConcurrentHashMap<>();
    private final Map<String, Operation> runningOperations = new ConcurrentHashMap<>(); //key: operation id, value: operation
    private final Map<String, Session> runningSessions = new ConcurrentHashMap<>(); //key: session id, value: session
    private final Map<String, String> operationsToSessions = new ConcurrentHashMap<>(); //key: operation id, value: session id

    @Autowired
    private SessionEngine(ThreadingManager threadingManager, DiagnosticManager diagnosticManager, LoggingManager loggingManager, SessionConfig sessionConfig, HostConfig hostConfig) {
        this.threadingManager = threadingManager;
        this.diagnosticManager = diagnosticManager;
        this.loggingManager = loggingManager;
        this.sessionConfig = sessionConfig;
        this.localhostConfig = hostConfig.getLocal();

        sessionProperties.put("sixsense.session.version", this.sessionConfig.getVersion());
        for(Map.Entry<String, String> prompt : this.sessionConfig.getPrompt().entrySet()){
            String promptName = prompt.getKey();
            String promptText = prompt.getValue();
            sessionProperties.put("sixsense.session.prompt." + promptName, promptText);
        }

        logger.info("Session engine initialized");
    }

    public OperationResult executeOperation(Operation operation){
        Session session = null;
        OperationResult operationResult;

        try {
            session = initializeSession(operation); //Initiate a new session (will finalize if failed to initialize)
            operationResult = executeOperation(session, operation); //use the new session to execute the operation
            finalizeSession(session, operation.getUUID()); //finalize the session and release any resources generated by the session
        } catch (Exception e){
            String errorMessage = "SessionEngine - Failed to execute operation " + operation.getOperationName() + ". Caused by: " + e.getMessage();
            logger.error(errorMessage);
            operationResult = new OperationResult().withExpressionResult(
                this.handleExecutionAnomaly(session, errorMessage)
            );
        }

        return operationResult;
    }

    public OperationResult executeOperation(Session session, Operation operation) {
        OperationResult operationResult = new OperationResult();

        if(operation == null){
            operationResult.setExpressionResult(
                handleExecutionAnomaly(session, "Session engine cannot execute a null operation!")
            );
        }else if(session.isClosed()){
            operationResult.setExpressionResult(
                handleExecutionAnomaly(session, Literals.SessionAlreadyClosed)
            );
        }else if(operation.getExecutionBlock() == null){
            operationResult.setExpressionResult(
                handleExecutionAnomaly(session, "Operation " + operation.getUUID() + " has incomplete configuration")
            );
        }else{
            session.incrementDrilldownRank();
            diagnosticManager.emit(new OperationStartEvent(session, operation));

            try {
                preExecute(session, operation);
                ICommand executionBlock = operation.getExecutionBlock();

                if (executionConditionsMet(session, operation)) {
                    operationResult.setExpressionResult(
                        executeBlock(session, executionBlock)
                    );
                    operationResult.setExpressionResult(
                        expectedResult(operationResult.getExpressionResult(), operation.getExpectedOutcome().getExpressionResult())
                    );
                } else {
                    operationResult.setExpressionResult(
                        ExpressionResult.skip()
                    );
                }

                postExecute(session, operation);
                diagnosticManager.emit(new OutcomeEvaluationEvent(session, "", operation.getExpectedOutcome()));
            } catch (Exception e) {
                String errorMessage = "SessionEngine - Failed to execute operation " + operation.getOperationName() + ". Caused by: " + e.getMessage();
                logger.error(errorMessage);
                operationResult.setExpressionResult(
                    handleExecutionAnomaly(session, errorMessage)
                );
            }

            operationResult.addDatabaseVariables(session.getDatabaseVariables());
            diagnosticManager.emit(new OperationEndEvent(session, operation, operationResult));
            session.decrementDrilldownRank();
        }

        return operationResult;
    }

    private ExpressionResult executeBlock(Session session, ICommand executionBlock) throws IOException{
        ExpressionResult blockResult = null;
        if(session.isClosed()){
            blockResult = handleExecutionAnomaly(session, Literals.SessionAlreadyClosed);
        }else if (executionBlock instanceof Command) {
            blockResult = executeCommand(session, (Command)executionBlock);
        }else if(executionBlock instanceof Block){
            /*the progressive result updates for each of the blocks child commands/blocks
            * progressive + failure = immediate return
            * progressive + skip = progressive
            * progressive + success = success*/
            Block parentBlock = (Block)executionBlock;
            ExpressionResult progressiveResult = ExpressionResult.defaultOutcome();

            diagnosticManager.emit(new BlockStartEvent(session, parentBlock));
            preExecute(session, parentBlock);

            if(executionConditionsMet(session, parentBlock)) {
                while (!parentBlock.hasExhaustedCommands(session)) {
                    ICommand nextCommand = parentBlock.getNextCommand(session);
                    if (nextCommand != null) {
                        ExpressionResult commandResult = executeBlock(session, nextCommand);
                        if (commandResult.getOutcome().equals(ResultStatus.FAILURE)){
                            blockResult = commandResult;
                            break;
                        }else if(!commandResult.getOutcome().equals(ResultStatus.SKIP)){
                            progressiveResult = commandResult;
                        }
                    }
                }
            }else{
                progressiveResult = ExpressionResult.skip();
            }

            postExecute(session, parentBlock);
            if(blockResult == null) {// which (before this line) can only be assigned if commandResult has ResultStatus.FAILURE
                blockResult = expectedResult(progressiveResult, parentBlock.getExpectedOutcome().getExpressionResult());
            }

            diagnosticManager.emit(new OutcomeEvaluationEvent(session, "", parentBlock.getExpectedOutcome()));
            diagnosticManager.emit(new BlockEndEvent(session, parentBlock, blockResult));
        }else{
            blockResult = handleExecutionAnomaly(session, Literals.InvalidExecutionBlock);
        }
        return blockResult;
    }

    private ExpressionResult executeCommand(Session session, Command currentCommand) throws IOException{
        ExpressionResult commandResult;

        if(session.isClosed()){
            commandResult = handleExecutionAnomaly(session, Literals.SessionAlreadyClosed);
        }else{
            diagnosticManager.emit(new CommandStartEvent(session, currentCommand));
            preExecute(session, currentCommand);

            if (executionConditionsMet(session, currentCommand)) {
                commandResult = session.executeCommand(currentCommand);
            } else {
                commandResult = ExpressionResult.skip();
            }

            postExecute(session, currentCommand);
            diagnosticManager.emit(new CommandEndEvent(session, currentCommand, commandResult));
        }

        return commandResult;
    }

    private boolean executionConditionsMet(Session session, ICommand command){
        return LogicalExpressionResolver.resolveLogicalExpression(
                session.getCurrentSessionVariables(),
                command.getExecutionCondition()
        ).isResolved();
    }

    private ExpressionResult expectedResult(ExpressionResult achievedResult, ExpressionResult parentResult){
        /*If the result of executing the block was expected by the parent (i.e. they are equal in the weak sense), override it with the parent result
         * Otherwise, return the result as is was returned from the executeBlock() method*/
        if(parentResult.strongEquals(ExpressionResult.defaultOutcome())){
            return achievedResult;
        } else if(achievedResult.equals(parentResult)){
            return parentResult;
        }else{
            return achievedResult;
        }
    }

    private ExpressionResult handleExecutionAnomaly(Session session, String message){
        ExpressionResult executionError = ExpressionResult.executionError(message);
        diagnosticManager.emit(new ExecutionAnomalyEvent(session, executionError));
        return executionError;
    }

    //Attempts to create a new session
    public Session initializeSession(Operation operation) throws InstantiationException{
        Session session;
        try{
            session = (Session) this.appContext.getBean("sixSenseSession", operation);
        } catch (BeansException e){
            logger.error("SessionEngine - Failed to initialize a new session for operation " + operation.getOperationName() + ". Caused by: " + e.getMessage());
            throw new InstantiationException(e.getMessage());
        }

        this.runningSessions.put(session.getSessionShellId(), session);
        this.runningOperations.put(operation.getUUID(), operation);
        this.operationsToSessions.put(operation.getUUID(), session.getSessionShellId());
        diagnosticManager.emit(new SessionCreatedEvent(session));

        return session;
    }

    //Create a prototype session bean, generate the required I/O channels and load session variables. If fails, will finalize the session to prevent it from executing commands
    @Bean(value="sixSenseSession")
    @Scope("prototype")
    private Session createSession(Operation operation) throws InstantiationException, IOException, NullPointerException{
        if(operation == null){
            throw new NullPointerException("Cannot create a session using a null operation!");
        }

        Session session = new Session(this.localhostConfig, operation.getChannelNames(), operation.getUUID());
        session.loadSessionVariables(sessionProperties);
        ThreadContext.put("sessionID", session.getShortSessionId());
        ThreadingUtils.updateSessionAndOperationIds(session.getShortSessionId(), operation.getShortUUID());

        try {
            List<ProcessStreamWrapper> wrappers = session.getShellChannels().values().stream()
                    .map(ShellChannel::getChannelOutputWrapper)
                    .collect(Collectors.toList());

            for(ProcessStreamWrapper wrapper : wrappers){
                this.threadingManager.submit(wrapper);
            }
        }catch (Exception e){
            String message = "Failed to create new session - could not submit channel IO streams to worker queue. Caused by: " + e.getMessage();
            logger.error(message);

            finalizeSession(session);
            throw new IOException(message);
        }

        return session;
    }

    public void finalizeSession(Session session, String operationUUID) throws IOException{
        this.operationsToSessions.remove(operationUUID);
        this.runningOperations.remove(operationUUID);
        this.runningSessions.remove(session.getSessionShellId());
        finalizeSession(session);
    }

    private void finalizeSession(Session session) throws IOException{
        try {
            session.close();
            diagnosticManager.emit(new SessionClosedEvent(session));
        } catch (IOException e) {
            logger.error("SessionEngine - Failed to finalize session with id " + session.getSessionShellId() + ". Caused by: " + e.getMessage());
            throw e;
        } finally {
            ThreadContext.remove("sessionID");
            ThreadingUtils.updateLifecyclePhase(EngineEventType.NotInSession);
            loggingManager.closeLoggers(session.getShortSessionId());
        }
    }

    public OperationResult terminateOperation(String operationID){
        ExpressionResult terminationResult;
        String sessionID = this.operationsToSessions.get(operationID);

        if(sessionID == null) {
            terminationResult = ExpressionResult.executionError("Operation " + operationID + " is not currently running, and therefore cannot be terminated");
            logger.warn(terminationResult.getMessage());
        }else{
            this.runningOperations.remove(operationID);
            Session terminatingSession = this.runningSessions.remove(sessionID);
            if (terminatingSession == null) {
                terminationResult = ExpressionResult.executionError("Operation " + operationID + " was paired with session " + sessionID + ", but the session is not currently running");
                logger.warn(terminationResult.getMessage());
            } else {
                try {
                    terminatingSession.terminate();
                    finalizeSession(terminatingSession, operationID);
                    terminationResult = ExpressionResult.executionError(Literals.OperationTerminated);
                } catch (IOException e) {
                    logger.error("Failed to terminate session " + terminatingSession.getSessionShellId() + ". Caused by: " + e.getMessage());
                    terminationResult = handleExecutionAnomaly(terminatingSession, Literals.ExceptionEncountered);
                }
            }
        }

        return new OperationResult().withExpressionResult(terminationResult);
    }

    private void preExecute(Session session, ICommand currentCommand){
        session.incrementDrilldownRank();
        session.loadSessionDynamicFields(currentCommand);
        diagnosticManager.emit(new ConditionEvaluationEvent(session, currentCommand.getExecutionCondition()));
    }

    private void postExecute(Session session, ICommand currentCommand){
        session.removeSessionDynamicFields(currentCommand);
        session.decrementDrilldownRank();
        currentCommand.setAlreadyExecuted(true);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) {
        this.appContext = applicationContext;
    }

    public static Map<String, String> getSessionProperties(){
        return Collections.unmodifiableMap(sessionProperties);
    }

    public static Map<String, String> addSessionProperties(Map<String, String> updatedConfig) {
        //updates the session properties for the current run of the engine
        sessionProperties.putAll(updatedConfig);
        return Collections.unmodifiableMap(sessionProperties);
    }

    public Map<String, Operation> getRunningOperations() {
        return Collections.unmodifiableMap(runningOperations);
    }

    public Map<String, Session> getRunningSessions() {
        return Collections.unmodifiableMap(runningSessions);
    }

    public Map<String, String> getOperationsToSessions(){
        return Collections.unmodifiableMap(operationsToSessions);
    }
}
