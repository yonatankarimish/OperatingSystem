# OperationEngine
### This project is an attempt to write an automation tool in Java that automates the execution of arbitrary scripts on network devices


#### Follow the following steps to create a working development environment for yourself.

#### Requirements:  
Due to the nature of managing network devices, the engine requires at least three virtual machines (vm) to be installed. The code deployed here was tested on vm's running Ubuntu 16.04 xenial as their operating system.  

Therefore, please generate three vm's running Ubuntu 16.04:  
1. Engine (Java): will host the JVM instance running the Operation Engine  
2.  Ansible (Control): will run the Ansible control node, generating the right environment for your Engine vm's  
3. RabbitMQ (Broker): will allow the Engine vm to interface with a RabbitMQ broker, making itself available for consuming messages sent over AMQP  

> Currently, the vm's supporting the project (Ansible and RabbitMQ) are static, already up and running. As development progresses, the plan is to generate the vm's using Vagrant and auto-running the build process to allow new developers to get up and running by running a few simple commands.  

Once finished, download and install the following languages and frameworks on your development pc:  
1. Java 11 SDK (https://jdk.java.net/java-se-ri/11)  
2. Node JS (https://nodejs.org/en/download/)  
3. Yarn (https://yarnpkg.com/getting-started/install)  
4. Maven (https://maven.apache.org/download.cgi)  
5. Git (https://git-scm.com/downloads)

Make sure to add all environment variables. It might also be a good idea to restart your working pc after finishing all the installations.  

#### Checkout project:  
Create a working directory on your development pc, then checkout the code for this project into your local working directory:  
`git clone https://github.com/yonatankarimish/OperationEngine.git`  

Then open the directory in your favourite IDE and create a new project from the newly-created source directory.  

#### Build your developer environment:  
The project uses a build chain composed of npm scripts. The main ones (at the time of writing) are:

```javascript
  "scripts": {
    "clean": "mvn clean",
    "init-dev": "yarn && node ./scripts/init-dev.js",
    "build-web": "rimraf ./src/main/resources/web/* && parcel build ./web/index.html --out-dir src/main/resources/web",
    "build-jar": "mvn clean package -DskipTests=true",
    "upload-ansible": "node ./scripts/ssh-upload.js --task=control",
    "upload-jar": "node ./scripts/ssh-upload.js --task=jar",
    "upload-tests": "node ./scripts/ssh-upload.js --task=tests",
    "upload-dependencies": "node ./scripts/ssh-upload.js --task=dependencies",
    "upload-all": "node ./scripts/ssh-upload.js --task=all",
    "deploy": "yarn deploy-jar",
    "deploy-web": "yarn build-web && yarn deploy-jar",
    "deploy-jar": "yarn build-jar && yarn upload-jar",
    "deploy-tests": "yarn build-jar && yarn upload-tests",
    "deploy-full": "yarn build-web && yarn build-jar && yarn upload-all"
  }
```

1. "clean": Cleans the jar files generated by Maven  
2. "init-dev": Initialized the devleoper environment on the local working pc  
3. "build-{blah}": Generates the files for the specified build step  
4. "upload-{blah}": Transfers the files generated by the matching build step to the correct vm  
5. "deploy-{blah}": Combines the right build step with the matching upload step  

This makes the first step opening a CLI (standalone or IDE-integrated) and running yarn init-dev.  
You will need to enter the credentials for the vm's you created in the Requirements step, which will allow future deployments with ease.

Once finished, login to your Ansible control vm and run the initialization playbook:  
```ansible
ansible-playbook sixsense_playbook.yaml -v -u root
```


The Ansible playbook will generate the runtime environment for the Operation Engine on it's assigned vm.  
> In the future, the Ansible playbook will run automatically as part of the init-dev build script. Until then we will need to run it manually.

#### Update your changes:  
Most of your work will consist of improving the Java codebase of the engine. In order to deploy, run "yarn deploy" in your local cli to upload your changes to the Engine vm.  

The Engine is wrapped by an OS service called "engine". The deployment process will restart the engine service for you. If you wish, you can enter "service engine stop" and "service engine start" in the Engine vm's cli to manually stop/start your Engine.

If for any reason you need to run the engine without it's wrapping service (debugging, breaking the whole start process etc...), run the following command in the Engine vm's cli:  
```bash
java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=0.0.0.0:5005 -jar /sixsense/OperationEngine.jar
```

#### Directory structure, configuration and log files: 
The engine vm deploys the Engine files under "/sixsense". From there, the directory structure is as follows:
```
/sixsense 
│
└───/config
│   │   sixsense-hosts.yaml
│   │   sixsense-session.yaml
│   └─  sixsense-threading.yaml
│   
└───/dependency-jars
|   │   dependency1.jar
|   │   dependency2.jar
│   └─  ...
|
└───/logs
|   |
│   └───/sessions
│   |   │───/{session_id}
│   |   │   |   command.log
│   |   │   |   session.log
│   |   │   └   terminal.log
│   |   │───/{session_id_2}
│   |   └─  ...
|   │ 
|   │   general_{date}.log
|   └─  general_latest.log
|
│   OperationEngine.jar
│   OperationEngine-tests.jar
```

Main points of interest:  
1. the /config directory holds the engine configuration files. While the current contents are mapped to type-safe java classes, you can add any .yaml file to this directory, and it will be mapped to environment properties available for the engine to use.  
2. the /logs/sessions/{session_id} directory holds the outputs of the relevant session. command.log gives a simplified input/output flow of the session; session.log gives the full analysis of the session execution, and terminal.log gives the exact (if a little flawed) outputs of the session to the connected pseudo-terminal.
3. OperationEngine.jar is uploaded by running "yarn upload-jar", OperationEngine-tests is uploaded by running "yarn upload-tests" and the /dependency-jars folder is uploaded by running "yarn upload-dependencies". The web ui is bundled as part of the OperatingSystem.jar

> In the future, we plan to apply additional configuration by sending it over HTTP or AMQP during startup. Until then, we rely on static configuration in the /config directory, generated by the Ansible control vm as part of the init-dev process.

#### Notes:  
The project is not yet production ready, and is updated on a spare-time basis. While trying to be a full-fledged product, there is still much progress until it reaches there.  

Main upgrades pending to be implemented:  
1. Mounting of external file systems for engine logs  
2. Everything to do with authentication, authorization and security (https support, password encrytion, user permissions, isolated file-system etc...)  
3. Database integration (configuration pushing, result submission, pojo id's etc..)  
4. Proper git workflow (right now everything is on a single master branch)  
5. Workflow implemetation (parallel workflows, steps, dynamic fields in a workflow context etc...)  
6. Container deployment (Docker, Micro-service, Kubernetes)  
7. Finish the build process (Vagrant to create vm's, Build scripts to register with Ansible contorl vm, then initialize development on vm)  
8. Documentation - currently exists as inline comments, should be expanded to provide a "soft-landing" to the Engine
9. Testing - reach as close to 100% coverage as possible (unit tests, e2e tests, stress tests etc...)  
  
  
May the odds be ever in our favour